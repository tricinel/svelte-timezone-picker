{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../Demo.svelte",
    "../../Picker.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import Picker from '../src/Picker.svelte';\n  import { zonedTimeToUtc } from 'date-fns-tz';\n  import { format } from 'date-fns';\n\n  let datetime = '2020-06-10T19:30';\n  let timezone = 'Europe/London';\n\n  let dt = zonedTimeToUtc(datetime, timezone);\n\n  let payload = {\n    datetime,\n    timezone,\n    dt\n  };\n\n  const update = (ev) => {\n    payload.timezone = ev.detail.timezone;\n    payload.dt = ev.detail.datetime;\n  };\n</script>\n\n<div class=\"cols\">\n  <div class=\"col\">\n    <p>Somewhere in Haikuland...</p>\n    <input type=\"datetime-local\" value=\"{datetime}\" />\n    <Picker on:update=\"{update}\" {datetime} {timezone} />\n  </div>\n  <div class=\"col\">\n    <p>The payload for the server will be:</p>\n    <pre>{JSON.stringify(payload, null, 2)}</pre>\n    <p>{format(payload.dt, \"MMMM do, yyyy 'at' HH:mm aaaa\")}</p>\n  </div>\n</div>\n\n<style>\n  .cols {\n    background: #fafafa;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    display: flex;\n    margin: 2em 0;\n  }\n\n  .col {\n    padding: 1em;\n  }\n\n  p {\n    color: #9c9c9c;\n    font-size: 0.8em;\n  }\n\n  pre {\n    background: #fff;\n    border: 1px solid #ccc;\n    border-radius: 2px;\n    padding: 0.4em;\n  }\n\n  input {\n    margin: 0.4em 0 2em;\n  }\n</style>\n",
    "<script>\n  import {\n    createEventDispatcher,\n    onMount,\n    onDestroy,\n    afterUpdate\n  } from 'svelte';\n  import { slide } from 'svelte/transition';\n  import { utcToZonedTime, zonedTimeToUtc } from 'date-fns-tz';\n  import { format, isValid } from 'date-fns';\n  import groupedZones from './timezones.json';\n  import {\n    scrollIntoView,\n    uid,\n    getKeyByValue,\n    slugify,\n    keyCodes\n  } from './utils';\n  import IconWorld from './IconWorld.svelte';\n  import IconArrow from './IconArrow.svelte';\n  import IconClose from './IconClose.svelte';\n\n  // ***** Public API *****\n\n  // The datetime and timezone values come from the consumer of the component\n  // If either is not provided, we will set them in onMount to be the current date and the user's timezone\n  export let datetime = null;\n  export let timezone = null;\n\n  // Should the dropdown be open by default?\n  export let open = false;\n\n  // ***** End Public API *****\n\n  // We will use the dispatcher to send the update event\n  const dispatch = createEventDispatcher();\n\n  // What is the current zone?\n  let currentZone;\n\n  // We will get a ref to the toggleButton so that we can manage focus\n  let toggleButtonRef;\n\n  // Emit the event back to the consumer\n  const handleTimezoneUpdate = (event, zoneId) => {\n    currentZone = zoneId;\n    timezone = ungroupedZones[zoneId];\n    reset();\n    dispatch('update', {\n      timezone,\n      datetime: zonedTimeToUtc(datetime, timezone)\n    });\n    toggleButtonRef.focus();\n    event.preventDefault();\n  };\n\n  // We keep track of the initial state so we can reset to these values when needed\n  const initialState = {\n    open,\n    userSearch: null\n  };\n\n  // A few IDs that will we use for a11y\n  const labelId = uid();\n  const listBoxId = uid();\n  const clearButtonId = uid();\n  const searchInputId = uid();\n\n  // We take the grouped timezones and flatten them so that they can be easily searched\n  // e.g. { Europe: { 'London': 'Europe/London', 'Berlin': 'Europe/Berlin' } } => {'London': 'Europe/London', 'Berlin': 'Europe/Berlin' }\n  const ungroupedZones = Object.values(groupedZones).reduce(\n    (values, zone) => ({ ...values, ...zone }),\n    {}\n  );\n\n  // We take the ungroupedZones and create a list of just the user-visible lables\n  // e.g. {'London': 'Europe/London', 'Berlin': 'Europe/Berlin' } => ['London', 'Berlin']\n  const zoneLabels = Object.keys(ungroupedZones);\n\n  // We also want a list of all the valid zones\n  // e.g. {'London': 'Europe/London', 'Berlin': 'Europe/Berlin' } => ['Europe/London', 'Europe/Berlin']\n  const validZones = Object.values(ungroupedZones);\n\n  // Zones will be filtered as the user types, so we keep track of them internally here\n  let filteredZones = [];\n\n  // We keep track of what the user is typing in the search box\n  let userSearch;\n\n  // What is the currently selected zone in the dropdown?\n  let highlightedZone;\n\n  // ***** Methods *****\n\n  // Given a Date and a timezone, give the correct Date and Time for that timezone\n  const getTimeForZone = (d, t) => utcToZonedTime(d, t);\n\n  // Figure out if a grouped zone has any currently visible zones\n  // We use this when the user searches in order to show/hide the group name in the list\n  const groupHasVisibleChildren = (group, zones) =>\n    Object.keys(groupedZones[group]).some((zone) => zones.includes(zone));\n\n  // Scroll the list to a specific element in it if that element is not already visible on screen\n  const scrollList = (zone) => {\n    const listElement = document.getElementById(listBoxId);\n    const zoneElement = document.getElementById(`tz-${slugify(zone)}`);\n    if (listElement && zoneElement) {\n      zoneElement.querySelector('button').focus();\n      scrollIntoView(zoneElement, listElement);\n    }\n  };\n\n  // Every time the user uses their keyboard to move up or down in the list,\n  // we need to figure out if their at the end/start of the list and scroll the correct elements\n  // into view\n  const moveSelection = (direction) => {\n    const len = filteredZones.length;\n    const zoneIndex = filteredZones.findIndex(\n      (zone) => zone === highlightedZone\n    );\n\n    let index;\n\n    if (direction === 'up') {\n      index = (zoneIndex - 1 + len) % len;\n    }\n\n    if (direction === 'down') {\n      index = (zoneIndex + 1) % len;\n    }\n\n    event.preventDefault();\n    // We update the highlightedZone to be the one the user is currently on\n    highlightedZone = filteredZones[index];\n    // We make sure the highlightedZone is visible on screen, scrolling it into view if not\n    scrollList(highlightedZone);\n  };\n\n  // We watch for when the user presses Escape, ArrowDown or ArrowUp and react accordingly\n  const handleKeydown = (ev) => {\n    // If the clearButton is focused, don't do anything else\n    if (document.activeElement === document.getElementById(clearButtonId)) {\n      return;\n    }\n\n    // If the user presses Escape, we dismiss the drodpown\n    if (ev.keyCode === keyCodes.Escape) {\n      reset();\n    }\n\n    // If the user presses the down arrow, start navigating the list\n    if (ev.keyCode === keyCodes.ArrowDown) {\n      moveSelection('down');\n    }\n    // If the user presses the up arrow, start navigating the list\n    if (ev.keyCode === keyCodes.ArrowUp) {\n      moveSelection('up');\n    }\n\n    // If the user presses Enter, select the current item\n    if (ev.keyCode === keyCodes.Enter && highlightedZone) {\n      handleTimezoneUpdate(ev, highlightedZone);\n    }\n\n    // If the user start to type letters or numbers, we focus on the Search field\n    if (keyCodes.Characters.includes(ev.keyCode)) {\n      document.getElementById(searchInputId).focus();\n    }\n  };\n\n  // Reset the dropdown and all internal state to the initial values\n  const reset = () => {\n    open = initialState.open;\n    userSearch = initialState.userSearch;\n  };\n\n  // When the user presses the clear button when searching,\n  // we want to clear the text and refocus on the input\n  const clearSearch = () => {\n    userSearch = initialState.userSearch;\n    // Refocus to the search input\n    document.getElementById(searchInputId).focus();\n  };\n\n  const setHighlightedZone = (name) => {\n    highlightedZone = name;\n  };\n\n  const toggleOpen = () => {\n    open = !open;\n  };\n\n  // ***** Reactive *****\n\n  // As the user types, we filter the available zones to show only those that should be visible\n  $: filteredZones =\n    userSearch && userSearch.length > 1\n      ? zoneLabels.filter((zoneLabel) =>\n          zoneLabel.toLowerCase().includes(userSearch.toLowerCase())\n        )\n      : zoneLabels.slice();\n\n  // ***** Lifecycle methods *****\n\n  // Just in case we need to auto-update the date, we keep track of the intervalId\n  // so that we can clear it and prevent memory leaks\n  let intervalId;\n  const UPDATE_INTERVAL = 1000 * 60; // 1 minute\n\n  onMount(() => {\n    const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n    if (timezone) {\n      // The timezone must be a valid timezone, so we check it against our list of values in flat\n      if (!Object.values(ungroupedZones).includes(timezone)) {\n        console.warn(\n          `The timezone provided is not valid: ${timezone}!`,\n          `Valid zones are: ${validZones}`\n        );\n        timezone = userTimezone;\n      }\n    } else {\n      timezone = userTimezone;\n    }\n\n    currentZone = getKeyByValue(ungroupedZones, timezone);\n\n    if (datetime && !isValid(datetime)) {\n      console.warn(`The datetime provided is not a valid date: ${datetime}`);\n      datetime = new Date();\n    }\n\n    // If the user didn't pass a date, then we assume it's a picker,\n    // and we update the time for each timezone every minute\n    if (!datetime) {\n      datetime = new Date();\n      intervalId = setInterval(() => {\n        datetime = new Date();\n      }, UPDATE_INTERVAL);\n    }\n  });\n\n  afterUpdate(() => {\n    // We need to wait for the DOM to be in sync with our open state\n    // and then scroll the list,\n    // because only at this point do we have access to document.getElementById()\n    if (open && highlightedZone) {\n      scrollList(highlightedZone);\n    }\n  });\n\n  onDestroy(() => {\n    // Prevent memory leaks and clean up the interval\n    if (intervalId) {\n      clearInterval(intervalId);\n    }\n  });\n</script>\n\n{#if open}\n  <div class=\"overlay\" on:click=\"{reset}\"></div>\n{/if}\n\n<div class=\"tz-container\">\n  <button\n    bind:this=\"{toggleButtonRef}\"\n    type=\"button\"\n    role=\"button\"\n    aria-label=\"{`${currentZone} is currently selected. Change timezone`}\"\n    aria-haspopup=\"listbox\"\n    data-toggle=\"true\"\n    aria-expanded=\"{open}\"\n    on:click=\"{toggleOpen}\"\n  >\n    <IconWorld />\n    <span>{currentZone}</span>\n    {#if datetime}\n      <small>({format(getTimeForZone(datetime, timezone), 'h:mm aaaa')})</small>\n    {/if}\n    <IconArrow transform=\"{open}\" />\n  </button>\n  {#if open}\n    <div class=\"tz-dropdown\" transition:slide on:keydown=\"{handleKeydown}\">\n      <label id=\"{labelId}\">\n        Select a timezone from the list. Start typing to filter or use the arrow\n        keys to navigate the list\n      </label>\n      <div class=\"input-group\">\n        <!-- svelte-ignore a11y-autofocus -->\n        <input\n          id=\"{searchInputId}\"\n          type=\"search\"\n          aria-autocomplete=\"list\"\n          aria-controls=\"{listBoxId}\"\n          aria-labelledby=\"{labelId}\"\n          autocomplete=\"off\"\n          autocorrect=\"off\"\n          placeholder=\"Search...\"\n          bind:value=\"{userSearch}\"\n          autofocus\n        />\n\n        {#if userSearch && userSearch.length > 0}\n          <button title=\"Clear search text\" on:click=\"{clearSearch}\">\n            <IconClose />\n          </button>\n        {/if}\n      </div>\n\n      <ul\n        tabindex=\"-1\"\n        class=\"tz-groups\"\n        id=\"{listBoxId}\"\n        aria-labelledby=\"{labelId}\"\n      >\n        {#each Object.keys(groupedZones) as group}\n          <li>\n            {#if groupHasVisibleChildren(group, filteredZones)}\n              <p>{group}</p>\n            {/if}\n            <ul\n              role=\"listbox\"\n              aria-activedescendant=\"{currentZone && `tz-${slugify(currentZone)}`}\"\n            >\n              {#each Object.keys(groupedZones[group]) as name}\n                {#if filteredZones.includes(name)}\n                  <li\n                    id=\"{`tz-${slugify(name)}`}\"\n                    role=\"option\"\n                    aria-selected=\"{highlightedZone === name}\"\n                  >\n                    <button\n                      on:click=\"{(event) => handleTimezoneUpdate(event, name)}\"\n                      on:mouseover=\"{() => setHighlightedZone(name)}\"\n                      aria-label=\"{`Select ${name}`}\"\n                    >\n                      {name}\n                      <span>\n                        {datetime && format(getTimeForZone(datetime, ungroupedZones[name]), 'h:mm aaaa')}\n                      </span>\n                    </button>\n                  </li>\n                {/if}\n              {/each}\n            </ul>\n          </li>\n        {/each}\n      </ul>\n    </div>\n  {/if}\n</div>\n\n<style>\n  .overlay {\n    background: transparent;\n    height: 100vh;\n    left: 0;\n    position: fixed;\n    top: 0;\n    width: 100vw;\n    z-index: 0;\n  }\n\n  .tz-container {\n    position: relative;\n    z-index: 1;\n  }\n\n  button {\n    background: transparent;\n    border: 0;\n    cursor: pointer;\n  }\n\n  button[data-toggle] {\n    align-content: flex-start;\n    align-items: center;\n    display: flex;\n  }\n\n  button[data-toggle] > span {\n    margin-left: 0.4em;\n  }\n\n  button[data-toggle] > span,\n  button[data-toggle] > small {\n    margin-right: 0.4em;\n  }\n\n  .tz-dropdown {\n    background-color: #fff;\n    border: 1px solid rgba(0, 0, 0, 0.2);\n    box-shadow: 0 1px 6px 0 rgba(0, 0, 0, 0.2);\n    border-radius: 4px;\n    display: flex;\n    flex-direction: column;\n    position: absolute;\n    z-index: 50;\n  }\n\n  .tz-groups {\n    height: 240px;\n    max-height: 40vh;\n    overflow: scroll;\n  }\n\n  ul {\n    margin: 0;\n    list-style: none inside none;\n    padding: 0;\n  }\n\n  ul li {\n    font-size: 0.9rem;\n    display: block;\n    margin: 0;\n    padding: 0;\n  }\n\n  ul li p {\n    color: var(--color-gray-900, #292929);\n    font-size: 0.92rem;\n    font-weight: 600;\n    letter-spacing: 0.08em;\n    padding-left: 0.8em;\n    text-transform: uppercase;\n  }\n\n  ul li button {\n    background: transparent;\n    border: 0;\n    color: var(--color-gray-600, #757575);\n    cursor: pointer;\n    display: flex;\n    justify-content: space-between;\n    padding: 0.8em 1.2em;\n    text-align: left;\n    width: 100%;\n  }\n\n  ul li button:hover,\n  ul li button:focus,\n  li[aria-selected='true'] button {\n    background: var(--color-info, #076196);\n    color: #fff;\n  }\n\n  .input-group {\n    display: flex;\n    position: relative;\n  }\n\n  .input-group > button {\n    position: absolute;\n    top: 1.2em;\n    right: 0.8em;\n  }\n\n  input {\n    border: 1px solid var(--color-gray-400, #acacac);\n    border-radius: 4px;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.12);\n    margin: 0.4em;\n    padding: 0.6em 1.6em 0.6em 0.4em;\n    width: calc(100% - 0.8em);\n  }\n\n  label {\n    border: 0;\n    clip: 'rect(0, 0, 0, 0)';\n    height: 1px;\n    margin: -1px;\n    opacity: 0;\n    overflow: hidden;\n    padding: 0;\n    position: absolute;\n    width: 1px;\n  }\n</style>\n"
  ],
  "names": [],
  "mappings": "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"
}